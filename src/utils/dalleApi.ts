import OpenAI from 'openai';
import { createClient } from '@supabase/supabase-js';
import { Database } from '@/types/supabase';

// Lazy initialization of OpenAI client to avoid errors when API key is missing
let openai: OpenAI | null = null;

function getOpenAIClient(): OpenAI | null {
  if (!process.env.OPENAI_API_KEY) {
    return null;
  }
  
  if (!openai) {
    openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY!,
    });
  }
  
  return openai;
}

const supabase = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

// DALL-E 이미지는 영구 저장 (비용이 높으므로)
const CACHE_DURATION = 1000 * 60 * 60 * 24 * 365; // 1년 (거의 영구적)

export interface DalleImage {
  id: string;
  url: string;
  alt_description: string;
  prompt: string;
  created_at: string;
}

// Local fallback images
const LOCAL_FALLBACK_IMAGES = [
  '/food1.jpg',
  '/food2.png',
  '/food3.jpg',
  '/mainfoodimage.jpg'
];

// Create a fallback DalleImage using local images
function createLocalFallback(query: string): DalleImage {
  const randomIndex = Math.floor(Math.random() * LOCAL_FALLBACK_IMAGES.length);
  const localImageUrl = LOCAL_FALLBACK_IMAGES[randomIndex];
  
  return {
    id: `local_fallback_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    url: localImageUrl,
    alt_description: `${query} food photo`,
    prompt: `Local fallback for: ${query}`,
    created_at: new Date().toISOString(),
  };
}

// Create a more specific and detailed prompt for better food image generation
function createFoodImagePrompt(recipeTitle: string): string {
  const cleanTitle = recipeTitle
    .replace(/recipe/gi, '')
    .replace(/dish/gi, '')
    .trim();
  
  return `A professional, mouth-watering photograph of ${cleanTitle}, beautifully plated on a clean white plate, shot from a 45-degree angle with natural lighting. The food should look fresh, appetizing, and restaurant-quality. High resolution, food photography style, vibrant colors, shallow depth of field background. No text, no watermarks.`;
}

function createRandomFoodPrompt(query: string): string {
  const cleanQuery = query
    .replace(/food/gi, '')
    .replace(/cooking/gi, '')
    .replace(/kitchen/gi, '')
    .trim();
  
  return `A stunning, professional food photograph featuring ${cleanQuery}, beautifully styled and plated, shot with professional lighting. Restaurant-quality presentation, vibrant colors, appetizing appearance. High-resolution food photography style, no text, no watermarks.`;
}

export async function generateRecipeImage(recipeTitle: string): Promise<DalleImage | null> {
  const cacheKey = `dalle:recipe:${recipeTitle.toLowerCase().trim()}`;

  try {
    // Check OpenAI API key
    if (!process.env.OPENAI_API_KEY) {
      console.warn('OpenAI API key not found, using local fallback');
      return createLocalFallback(recipeTitle);
    }

    // 1. Try Supabase cache
    const { data: cache, error } = await supabase
      .from('dalle_cache')
      .select('*')
      .eq('recipe_title', recipeTitle)
      .single();

    if (!error && cache) {
      const cacheAge = Date.now() - new Date(cache.updated_at).getTime();
      if (cacheAge <= CACHE_DURATION) {
        try {
          const imageData = typeof cache.image_data === 'string'
            ? JSON.parse(cache.image_data)
            : cache.image_data;

          return imageData as DalleImage;
        } catch (error) {
          console.error('Error processing Supabase cache:', error);
          await supabase.from('dalle_cache').delete().eq('recipe_title', recipeTitle);
        }
      } else {
        // Cache expired, delete it
        await supabase.from('dalle_cache').delete().eq('recipe_title', recipeTitle);
      }
    }

    // 3. Generate new image with DALL-E
    console.log('Generating new DALL-E image for:', recipeTitle);
    const prompt = createFoodImagePrompt(recipeTitle);
    
    const openaiClient = getOpenAIClient();
    if (!openaiClient) {
      console.warn('OpenAI client not available, using local fallback');
      return createLocalFallback(recipeTitle);
    }
    
    const response = await openaiClient.images.generate({
      model: "dall-e-3",
      prompt: prompt,
      n: 1,
      size: "1024x1024",
      quality: "standard",
      style: "natural"
    });

    if (!response.data || response.data.length === 0) {
      console.error('No image generated by DALL-E, using local fallback');
      return createLocalFallback(recipeTitle);
    }

    const generatedImage = response.data[0];
    if (!generatedImage.url) {
      console.error('No URL in DALL-E response, using local fallback');
      return createLocalFallback(recipeTitle);
    }

    const imageData: DalleImage = {
      id: `dalle_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      url: generatedImage.url,
      alt_description: `AI-generated image of ${recipeTitle}`,
      prompt: prompt,
      created_at: new Date().toISOString(),
    };

    // Cache the result
    try {
      await supabase.from('dalle_cache').upsert({
        recipe_title: recipeTitle,
        image_data: imageData,
        updated_at: new Date().toISOString()
      });
    } catch (error) {
      console.error('Error storing cache:', error);
    }

    return imageData;
  } catch (error) {
    console.error('Error generating DALL-E image:', error);
    console.log('Using local fallback due to error');
    return createLocalFallback(recipeTitle);
  }
}

export async function generateRandomFoodImage(query: string): Promise<DalleImage | null> {
  const cacheKey = `dalle:random:${query.toLowerCase().trim()}`;

  try {
    // Check OpenAI API key
    if (!process.env.OPENAI_API_KEY) {
      console.warn('OpenAI API key not found, using local fallback');
      return createLocalFallback(query);
    }

    // Generate new image
    console.log('Generating new random DALL-E image for:', query);
    const prompt = createRandomFoodPrompt(query);
    
    const openaiClient = getOpenAIClient();
    if (!openaiClient) {
      console.warn('OpenAI client not available, using local fallback');
      return createLocalFallback(query);
    }
    
    const response = await openaiClient.images.generate({
      model: "dall-e-3",
      prompt: prompt,
      n: 1,
      size: "1792x1024", // Landscape format for hero images
      quality: "standard",
      style: "natural"
    });

    if (!response.data || response.data.length === 0) {
      console.error('No image generated by DALL-E, using local fallback');
      return createLocalFallback(query);
    }

    const generatedImage = response.data[0];
    if (!generatedImage.url) {
      console.error('No URL in DALL-E response, using local fallback');
      return createLocalFallback(query);
    }

    const imageData: DalleImage = {
      id: `dalle_random_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      url: generatedImage.url,
      alt_description: `AI-generated ${query} food image`,
      prompt: prompt,
      created_at: new Date().toISOString(),
    };

    // Cache the result
    try {
      await supabase.from('dalle_cache').upsert({
        recipe_title: query,
        image_data: imageData,
        updated_at: new Date().toISOString()
      });
    } catch (error) {
      console.error('Error storing cache:', error);
    }

    return imageData;
  } catch (error) {
    console.error('Error generating random DALL-E image:', error);
    console.log('Using local fallback due to error');
    return createLocalFallback(query);
  }
}

export async function generateMultipleRecipeImages(recipeTitle: string, count: number = 2): Promise<DalleImage[]> {
  const images: DalleImage[] = [];
  
  try {
    // Generate main recipe image
    const mainImage = await generateRecipeImage(recipeTitle);
    if (mainImage) {
      images.push(mainImage);
    }

    // Generate additional variations if needed and if we have DALL-E available
    if (count > 1 && images.length > 0 && process.env.OPENAI_API_KEY) {
      const variationPrompts = [
        `Close-up detail shot of ${recipeTitle}, focusing on texture and ingredients, professional food photography`,
        `${recipeTitle} served in a rustic setting, overhead shot, natural lighting, food styling`
      ];

      for (let i = 1; i < count && i - 1 < variationPrompts.length; i++) {
        try {
          const openaiClient = getOpenAIClient();
          if (!openaiClient) {
            throw new Error('OpenAI client not available');
          }
          
          const response = await openaiClient.images.generate({
            model: "dall-e-3",
            prompt: variationPrompts[i - 1],
            n: 1,
            size: "1024x1024",
            quality: "standard",
            style: "natural"
          });

          if (response.data && response.data.length > 0 && response.data[0].url) {
            const variationImage: DalleImage = {
              id: `dalle_variation_${i}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
              url: response.data[0].url,
              alt_description: `AI-generated variation ${i} of ${recipeTitle}`,
              prompt: variationPrompts[i - 1],
              created_at: new Date().toISOString(),
            };
            images.push(variationImage);
          }
        } catch (error) {
          console.error(`Error generating variation ${i}:`, error);
          // Try fallback for variations
          const fallbackImage = createLocalFallback(`${recipeTitle} variation`);
          if (fallbackImage) {
            images.push(fallbackImage);
          }
        }
      }
    }

    return images;
  } catch (error) {
    console.error('Error generating multiple recipe images:', error);
    return images; // Return whatever we have
  }
} 